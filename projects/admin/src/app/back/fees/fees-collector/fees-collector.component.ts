import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ReactiveFormsModule, FormsModule } from '@angular/forms';
import { TournamentService } from '../../../common/services/tournament.service';
import { FeesCollectorService } from './fees-collector.service';
import { BehaviorSubject, from, Observable, of, switchMap } from 'rxjs';
import { club_tournament_extended, FEE_RATE, Game, Game_status, Gamer } from '../fees.interface';
import { PdfService } from '../../../common/services/pdf.service';
import { HorizontalAlignment, PDF_table } from '../../../common/interfaces/pdf-table.interface';
import { FFBplayer } from '../../../common/ffb/interface/FFBplayer.interface';
import { InputPlayerComponent } from '../../../common/ffb/input-licensee/input-player.component';
import { NgbModal } from '@ng-bootstrap/ng-bootstrap';
import { GetConfirmationComponent } from '../../modals/get-confirmation/get-confirmation.component';
import { ToastService } from '../../../common/services/toast.service';



@Component({
  selector: 'app-fees-collector',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule, FormsModule, InputPlayerComponent],
  templateUrl: './fees-collector.component.html',
  styleUrl: './fees-collector.component.scss'
})
export class FeesCollectorComponent {
  GAME_STATUS = Game_status;
  FEE_RATE = FEE_RATE;
  next_tournaments: club_tournament_extended[] = [];
  selected_tournament: club_tournament_extended | null = null;
  fee_rates = Object.values(FEE_RATE);
  selected_fee_rate: FEE_RATE = FEE_RATE.STANDARD;
  days_back: number = 0;
  private daysBack$ = new BehaviorSubject<number>(0);
  game!: Game;
  already_charged: boolean = false;
  pdfLoading = false;
  new_player!: FFBplayer | null;
  hideValidated: boolean = false;



  constructor(
    private tournamentService: TournamentService,
    private feesCollectorService: FeesCollectorService,
    private pdfService: PdfService,
    private modalService: NgbModal,
    private toastService: ToastService,

  ) {
    const chrono = (date: string) => {
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tournamentDate = new Date(date);
      if (tournamentDate < today) {
        return 'passed';
      } else if (tournamentDate.toDateString() === today.toDateString()) {
        return 'today';
      } else {
        return 'upcoming';
      }
    };

    const today = new Date();
    today.setHours(0, 0, 0, 0);
    this.daysBack$.pipe(
      switchMap(v => this.tournamentService.list_next_tournaments(v))
    ).subscribe(async (tournaments) => {
      const withStatus: club_tournament_extended[] = tournaments.map(t => ({ ...t, chrono: chrono(t.date) }));
      const statuses = await Promise.all(withStatus.map(t => this.feesCollectorService.check_tournament_status(t)));
      withStatus.forEach((t, i) => (t.status = statuses[i]));
      this.next_tournaments = withStatus;
    });

  }

  ngOnInit() {

    this.selected_tournament = this.feesCollectorService.get_tournament();  // persisté par le cache service

    this.feesCollectorService.game$.subscribe((game) => {
      if (this.selected_tournament) {   // true new game$ generated by selection of tournament
        this.game = game;
        // console.log('Game updated from service for tournament ', this.game);
      }
    });
  }


  set_tournament(tournament: club_tournament_extended) {
    this.selected_tournament = tournament;
    this.feesCollectorService.set_tournament(tournament);
    if (tournament.status === this.GAME_STATUS.RECOVERED) {
      this.toastService.showInfo('Gestion tournoi', 'Une restauration d\'un pointage partiel a été effectuée.');
      const modalRef = this.modalService.open(GetConfirmationComponent, { centered: true });
      modalRef.componentInstance.title = 'Voulez-vous plutôt repartir d\'une feuille blanche ?';
      modalRef.componentInstance.subtitle = `Oui : nouvelle feuille blanche  Non : la restauration sera utilisée. `;
      modalRef.result.then(async (answer: boolean) => {
        if (answer) {
          await this.feesCollectorService.reset_tournament_state(tournament);
          this.next_tournaments.map(t => {
            if (t.id === this.selected_tournament?.id) {
              t.status = Game_status.INITIAL;
            }
          });
        }
      });
    }
  }


  fee_rate_changed(fee_rate: FEE_RATE) {
    this.feesCollectorService.change_fee_rate(fee_rate);
    this.log_game_state();
  }

  one_week_back() {
    this.days_back += 7;
    this.daysBack$.next(this.days_back);
  }

  euros_collected(): number {
    return this.feesCollectorService.euros_collected();
  }
  stamps_collected(): number {
    return this.feesCollectorService.stamps_collected();
  }


  clear_added_player() {
    this.new_player = null; // or this.new_player = undefined;
  }

  check_status() {
    if (this.selected_tournament && this.selected_tournament.status !== Game_status.COMPLETED && this.all_gamers_validated()) {
      const modalRef = this.modalService.open(GetConfirmationComponent, { centered: true });
      modalRef.componentInstance.title = `Vous avez pointé tous les joueurs `;
      modalRef.componentInstance.subtitle = `Vous allez maintenant valider tampons et droits de table`;
      modalRef.result.then((answer: boolean) => {
        if (answer) {
          this.validate_fees();
          this.next_tournaments.map(t => {
            if (t.id === this.selected_tournament?.id) {
              t.status = Game_status.COMPLETED;
            }
          });
        }
      });
    } else {
      this.next_tournaments.map(t => {
        if (t.id === this.selected_tournament?.id) {
          t.status = Game_status.RECOVERED;
        }
      });
    }

  }

  clear_session() {

    this.game = null!;
    this.selected_tournament = null!;
    this.feesCollectorService.clear_tournament();
  }

  toggle_sort() {
    this.feesCollectorService.toggle_sort();
  }

  toggle_hide_validated() {
    this.hideValidated = !this.hideValidated;
  }

  shouldShowGamer(gamer: Gamer): boolean {
    if (!this.game?.alphabetic_sort || !this.hideValidated) {
      return true;
    }
    return !gamer.validated;
  }

  toggle_fee() {
    this.feesCollectorService.toggle_fee();
    this.log_game_state();

  }

  async validate_fees() {
    this.tables_to_pdf();
    await this.feesCollectorService.save_fees()
    this.clear_session();
  }

  add_player(player: FFBplayer | null) {
    if (player) {
      this.feesCollectorService.add_player(player);
      this.log_game_state();
    }
  }

  all_gamers_validated(): boolean {
    return !!this.game?.tournament && !!this.game && this.game.gamers.every(gamer => gamer.validated);
  }

  gamer_solvent(gamer: Gamer): boolean {
    return !gamer.is_member || gamer.in_euro || (gamer.game_credits >= (this.game.fees_doubled ? 2 : 1));
  }

  gamer_class(gamer: Gamer): string {
    let card_class = 'card h-100 nice_shadow';
    if (!gamer.enabled) {
      card_class += ' bg-success shadow-lg text-bg-success';
      return card_class;
    }

    if (gamer.validated) {
      card_class += ' bg-success shadow-lg text-bg-success';
    } else {
      if (gamer.is_member)
        card_class += ' border-primary';
      else {
        card_class += ' border-secondary';
      }
    }
    return card_class
  }

  async log_game_state() {
    if (this.selected_tournament && this.selected_tournament.status === Game_status.COMPLETED) return;
    await this.feesCollectorService.log_game_state();
  }


  private to_csv(filename: string, rows: string[]) {
    const csvContent = rows.join('\r\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename + '.csv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  export_csv_ns() {
    if (!this.game) return;
    const csvRows: string[] = [];
    for (let i = 0; i < this.game.gamers.length; i += 2) {
      const gamer1 = this.game.gamers[i]?.license ?? '';
      const gamer2 = this.game.gamers[i + 1]?.license ?? '';
      csvRows.push(`${gamer1};${gamer2}`);
    }
    const ns = csvRows.filter((_, i) => i % 2 === 0);
    this.to_csv('NS', ns);
  }

  export_csv_eo() {
    if (!this.game) return;
    const csvRows: string[] = [];
    for (let i = 0; i < this.game.gamers.length; i += 2) {
      const gamer1 = this.game.gamers[i]?.license ?? '';
      const gamer2 = this.game.gamers[i + 1]?.license ?? '';
      csvRows.push(`${gamer1};${gamer2}`);
    }
    const eo = csvRows.filter((_, i) => i % 2 === 1);
    this.to_csv('EO', eo);
  }

  export_csv_all() {
    if (!this.game) return;
    const csvRows: string[] = [];
    for (let i = 0; i < this.game.gamers.length; i += 2) {
      const gamer1 = this.game.gamers[i]?.license ?? '';
      const gamer2 = this.game.gamers[i + 1]?.license ?? '';
      csvRows.push(`${gamer1};${gamer2}`);
    }
    this.to_csv('tournoi', csvRows);
  }

  // PDF generation 


  sales_of_the_day_table: PDF_table = {
    title: '',
    headers: [],
    alignments: [],
    rows: []
  };

  printTable() {
    this.pdfLoading = true;
    setTimeout(() => {
      this.tables_to_pdf();
      this.pdfLoading = false;
    }, 100);
  }



  tables_to_pdf() {

    const gamers_table = this.build_gamers_table();

    let fname = this.game.tournament
      ? `${this.game.tournament.date}_${this.game.tournament.name}.pdf`
      : 'feuille_presence.pdf';


    this.pdfService.generateTablePDF([gamers_table, this.sales_of_the_day_table], fname);

  }

  build_gamers_table(): PDF_table {

    let payment = (gamer: Gamer) => {
      if (!gamer.validated) return '';
      if (gamer.enabled) {
        return gamer.in_euro ? (gamer.price.toFixed(2) + ' €') : ((this.game.fees_doubled ? 2 : 1) + ' tampon(s)');
      } else {
        return this.game.fee_rate === 'accession' ? 'forfait' : 'non payant';
      }
    }

    if (!this.game || !this.game.gamers) return { title: '', headers: [], alignments: [], rows: [] };
    const title = 'recettes : ' + this.stamps_collected() + ' tampon(s) et ' + this.euros_collected() + ' €';
    const headers = ['Joueur1', 'Paiement1', 'Joueur2', 'Paiement2'];
    const alignments: HorizontalAlignment[] = ['left', 'right', 'left', 'right'];
    const rows: any[] = [];
    for (let i = 0; i < this.game.gamers.length; i += 2) {
      const gamer1 = this.game.gamers[i];
      const gamer2 = this.game.gamers[i + 1];
      rows.push([
        gamer1 ? gamer1.lastname + ' ' + gamer1.firstname : '',
        gamer1 ? payment(gamer1) : '',
        gamer2 ? gamer2.lastname + ' ' + gamer2.firstname : '',
        gamer2 ? payment(gamer2) : ''
      ]);
    }
    return { title, headers, alignments, rows };
  }


}